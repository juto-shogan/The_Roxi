import unittest
from unittest.mock import patch, MagicMock
import subprocess
from malware_attack import malware_attack


class TestRecon(unittest.TestCase):
    
    def setUp(self):
        self.recon = malware_attack.recon(target_ip="192.168.1.1")

    @patch("subprocess.check_output")
    def test_run_command_success(self, mock_subproc):
        """Test if run_command successfully returns output"""
        mock_subproc.return_value = b"Test Output"
        result = self.recon.run_command("echo Test")
        self.assertEqual(result, "Test Output")

    @patch("subprocess.check_output", side_effect=subprocess.CalledProcessError(1, "test"))
    def test_run_command_failure(self, mock_subproc):
        """Test if run_command handles command failure"""
        result = self.recon.run_command("invalid command")
        self.assertIsNone(result)

    def test_extract_ips_from_netdiscover(self):
        """Test IP extraction from Netdiscover output"""
        sample_output = """
            192.168.1.2  00:11:22:33:44:55
            192.168.1.3  66:77:88:99:AA:BB
        """
        extracted_ips = self.recon.extract_ips_from_netdiscover(sample_output)
        self.assertEqual(extracted_ips, ["192.168.1.2", "192.168.1.3"])

    @patch("malware_attack.malware_attack.recon.run_command")
    def test_run_nmap_on_ips(self, mock_run_command):
        """Test that run_nmap_on_ips calls run_command with correct IPs"""
        mock_run_command.return_value = "Open ports found"
        self.recon.run_nmap_on_ips(["192.168.1.2", "192.168.1.3"])
        mock_run_command.assert_any_call("nmap -sV 192.168.1.2")
        mock_run_command.assert_any_call("nmap -sV 192.168.1.3")

    @patch("malware_attack.malware_attack.recon.run_command")
    def test_detect_os(self, mock_run_command):
        """Test OS detection from Nmap results"""
        mock_run_command.return_value = "OS details: Windows"
        self.recon.detect_os(mock_run_command.return_value)
        self.assertEqual(self.recon.os, "Windows")

        mock_run_command.return_value = "OS details: Linux"
        self.recon.detect_os(mock_run_command.return_value)
        self.assertEqual(self.recon.os, "Linux")


class TestWeaponization(unittest.TestCase):

    def setUp(self):
        self.weapon = malware_attack.Weaponization()

    @patch("subprocess.run")
    def test_execute_script_success(self, mock_subproc):
        """Test script execution success"""
        mock_subproc.return_value = MagicMock(returncode=0)
        result = self.weapon.execute_script("scripts/keylogger.py")
        self.assertTrue(result)

    @patch("subprocess.run", side_effect=subprocess.CalledProcessError(1, "test"))
    def test_execute_script_failure(self, mock_subproc):
        """Test script execution failure with retries"""
        result = self.weapon.execute_script("scripts/nonexistent.py")
        self.assertFalse(result)

    @patch("malware_attack.malware_attack.Weaponization.execute_script")
    def test_deploy_malware(self, mock_execute):
        """Test that deploy_malware calls execute_script with correct script"""
        mock_execute.return_value = True
        self.weapon.deploy_malware("keylogger")
        mock_execute.assert_called_with("scripts/keylogger.py")


if __name__ == "__main__":
    unittest.main()
